---
layout: post
time: 2014-1-23
title: 《程序员面试宝典》(第三版)笔记+勘误
category: 笔试面试
keywords: 笔试面试,C/C++,勘误
tags: 笔试面试,C/C++
description: 最近在看《程序员面试宝典》,发现书中有很多错误及不清楚的地方，所以写下来给自己，也给觉得有用的大家。
---

#第5章 程序设计基本概念#

##5.1 赋值语句##

**面试例题1**

C++中main函数必须返回int，C中可以为void

无论C++还是C中，这一题的结果都是未定义的，每一次运行出来main里的i都是一个随机值.

此题可以这样理解，main函数里的`int i=i`这一行对于编译器来说做了两步：第一步声明一个`int i`变量，当声明这个局部变量时就隐藏了main函数外面的那个全局变量i，而此时新声明的这个局部变量i的值为随机值；第二步给局部变量i赋值，相当于把自己赋给自己，依然是一个随机的未定义值。

变量可以分为全局变量、静态全局变量、静态局部变量和局部变量

+ 按存储区域分：

	+ 全局变量、静态全局变量和静态局部变量都存放在内存的全局数据区
	+ 局部变量存放在内存的栈区

+ 按作用域分：

	+ 全局变量在整个工程文件内都有效；
	+ 静态全局变量只在定义它的文件内有效；
	+ 静态局部变量只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；
	+ 局部变量在定义它的函数内有效，但是函数返回后失效。

+ 全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。

**面试例题3**

此题给出求x转化为二进制后包含1的数量的简单解法

{% highlight C++ %}
int count1s(int x){
	int count = 0;
	while(x){
		++count;
		x = x & (x-1);
	}
	return count;
}
{% endhighlight %}

##5.2 i++##

**面试例题2**

注意C中`printf()`计算参数时是从右向左压栈的。

##5.4 类型转换##

**面试例题1**

32位机器中，int,long型为4个字节，short为2个字节，double为8个字节，char为1个字节。

float为单精度浮点数，内存中占4个字节，有效位6-7位，double为双精度，占8个字节，有效位15位。

`(int&)a`表示一个对int的引用，指向a，也就是将a的引用强制转换为整型，a所在的内存本来是double类型，但现在我非要按整型来解释它。

这道题考的点是：计算机中整型和浮点型的存储方式是不同的。

float型存储方式：

1		 |	8		 |	23       |
:-------:|:---------:|:---------:|
符号位	 | 	指数 	 |   尾数	 |

将一个实数转化为C++存储float格式步骤为：

1. 将实数的绝对值化为二进制格式，注意实数的整数部分和小数部分化为二进制的方法不同。

2. 将二进制格式的实数移动小数点化为科学计数法的格式，即小数点在第一位有效数字的右边，`1.XXXXX*2^1`。

3. E-127=n,得出的E为指数部分。

4. 实数为正数，符号位为0，负数为1。

5. XXXXX为尾数部分。

比如题目中的1.0f, 1.0转化为二进制是1.0*2\^0，所以符号位为0，指数位为127，尾数为0，写成存储方式是

0 011 1111 1000 0000 0000 0000 0000 0000

十六进制显示就是0x3f80000.

**面试例题2**

这道题把题目中的unsigned int a的值改为0x12345678,把最后要求输出的\*b改为\*(b+1)能解释的更加清楚一点。

首先，将unsigned int强制转换为unsigned char型，会进行截断，所以i为a的最后一个字节也就是0xF7.又因为是unsigned型，所以最后输出的时候左端会用0补齐。

其次，`char* b = (char*)&a`意思是b是一个指向char的指针，它的地址是`unsigned int a`的地址，但注意这里b是指向char的指针，所以输出\*b的话它会取出a的最后一个字节也就是0x78，输出\*(b+1)的话它会取出a的倒数第二个字节也就时0x56...etc.

第三点要说的是，因为b是`(signed)char*`类型的，所以要求输出32位十六进制时会在左端按正负补0或1，0x56/0x78的最高位都是0，所以会在左端补0而输出0x00000056/0x00000078，如果a的值为0x12348678,而输出\*(b+1)，由于0x86的最高位为1所以会在左端补1而输出0xFFFFFF86.

##5.5 运算符问题##

**面试例题1**

因为+的优先级高于位移，所以b等于将a取反后右移5位的低字节值。

这道题书中感觉没怎么讲明白。其实过程很简单。将a作取反操作时会进行整型提升，这可以通过`sizeof(~a)=4`来证实，提升时左边补0，所以a先变为0000 0000 0000 0000 0000 0000 1010 0101，取反后变为1111 1111 1111 1111 1111 1111 0101 1010。将a右移时，由于此时a默认提升为(signed int)型，所以右移时会根据符号位的正负来补0/1，所以`~a`右移5位后变为1111 1111 1111 1111 1111 1111 1111 1010(这里书中写错了),再转换为unsigned char时取低字节8位，即1111 1010，十进制即250.

**面试例题3**

解析中"这个的结果是x和y相同位的一半"不太准确，应该是x和y相同位的和的一半。

##5.6 a、b交换##

**面试例题1**

给出的两种方案都不太好，方案一没有考虑a+b溢出的情况，方案二的strs[]又给人感觉程序没有写完整一样，可以结合一下，PinkingS在这里给出一种解法:

{% highlight C++ %}
	int findLarger(int a, int b){
		int z = (unsigned)(a-b) >> (sizeof(int) * 8 - 1);
		return (1 - z) * a + z * b;
	}
{% endhighlight %}

#第6章 预处理、const与sizeof#

##6.1 宏定义##

**面试例题1**

上面定义的FIND宏就是要的e的偏移。这样强制转换后的结构指针怎么可以用来访问结构体字段？其实这个表达式根本没有也不打算访问e字段。`ANSI C标准允许任何值为0的常量被强制转换成任何一种类型的指针`，并且转换结果是一个NULL指针，因此`((struct*)0)`的结果就是一个类型为`struct*`的NULL指针。如果利用这个NULL指针来访问struct的成员当然是非法的，但`&(((struct*)0)->e)`的意图并非想存取e字段内容，而仅仅是计算当结构体实例的首址为`((struct*)0)`时e字段的地址。聪明的编译器根本就不生成访问e的代码，而仅仅是根据struct的内存布局和结构体实例首址在编译期计算这个(常量)地址，这样就完全避免了通过NULL指针访问内存的问题。又因为首址的值为0，所以这个地址的值就是字段相对于结构体基址的偏移。

扩展一下，现在知道这个变量的地址，求结构体的首地址

{% highlight Java %}
#define FIND(struct,pt,e ) ((size_t)pt-(size_t)(&(((struct*)0)->e)))
{% endhighlight %}

**面试例题2**

这道题里需要注意的有几点：

+ \#define的变量不是必须大写，但为了区分局部变量，定义的常量一般用大写字母表示
+ 16位机器能表示的最大unsigned int值是`2^16-1`即65535，最大signed int值是`2^15-1`即32767
+ 32位机器能表示的最大unsigned int值是`2^32-1`即4294967295，大约42亿，signed int最大能表示大约21亿。

**面试例题3**

宏定义中的参数最好加括号，因为宏替换就是简单的文本替换，加括号是为了处理表达式参数(参数可能是算法表达式)，使之更加通用。

例如，如果下面的宏定义参数不加括号：

{% highlight Java %}
#define COM(A+B) A*B
{% endhighlight %}

那么`COM(1+2,3)`会得到错误的结果.

##6.2 const##

**面试例题1**

将const修饰的常量说成是'只读变量'更好一些。

**面试例题2**

const和\#define的区别整理一下：

+ define宏是在预处理阶段展开的，const常量在编译运行阶段使用。
+ const定义的只读变量是有数据类型的，编译器可以对其进行数据类型检查，而#define宏定义的常量只是进行简单的字符`替换`，没有类型检查，且有时还会产生边际效应。
+ 有些调试程序可对const进行调试，但不对#define进行调试。
+ 当定义局部变量时，const作用域仅限于定义局部变量的函数体内。但用#define时其作用域不仅限于定义局部变量的函数体内，而是从定义点到整个程序的结束点。但也可以用#undef取消其定义从而限定其作用域范围。

另外：

C++中支持\#define是因为要兼容C，C++中不提倡用\#define来定义常量.

\#define也可以定义带参数的宏，C++中使用inline函数来代替。

补充关于指针和引用的一点：

指针和引用的区别很简单，就是引用更简洁，更安全。因为引用声明是必须初始化。 引用更接近const指针[^1]，一旦与某个变量关联，就将一直效忠于他。

[^1]: 补充关于const指针的一点：const指针可以接受const和非const地址，但是非const指针只能接受非const地址。所以const指针的能力更强一些，所以尽量多用const指针，这是一种习惯。


**未完待续。。。**

最后附上张小娴的一段话，祝愿每个人找到内心的充实与快乐。
![flower](http://photocdn.sohu.com/20140108/Img393153721.jpg =64x64)


> 我们每个人几乎都在说不快乐的事。事业成功的说工作压力大，工作清闲的说这行没前途，没成家的说遇不到适合的人，遇到的却说不合适。幸福像足球一样踢来踢去，烦恼像奖杯一样不可撒手。其实我们拥有的才是自己的幸福，争取的既是希望，失去的只是记忆，而快乐是源自内心。


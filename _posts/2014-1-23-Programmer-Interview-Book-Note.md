---
layout: post
time: 2014-1-23
title: 《程序员面试宝典》(第三版)笔记+勘误
category: 笔试面试
keywords: 笔试面试,C/C++,勘误
tags: 笔试面试,C/C++
description: 最近在看《程序员面试宝典》,发现书中有很多错误及不清楚的地方，所以写下来给自己，也给觉得有用的大家。
---

#第5章 程序设计基本概念#

##5.1##

###面试例题1###

C++中main函数必须返回int，C中可以为void

无论C++还是C中，这一题的结果都是未定义的，每一次运行出来main里的i都是一个随机值.

此题可以这样理解，main函数里的int i=i这一行对于编译器来说做了两步：第一步声明一个int i变量，当声明这个局部变量时就隐藏了main函数外面的那个全局变量i，而此时新声明的这个局部变量i的值为随机值；第二步给局部变量i赋值，相当于把自己赋给自己，依然是一个随机的未定义值。

变量可以分为全局变量、静态全局变量、静态局部变量和局部变量
按存储区域分：全局变量、静态全局变量和静态局部变量都存放在内存的全局数据区，局部变量存放在内存的栈区
按作用域分：全局变量在整个工程文件内都有效；静态全局变量只在定义它的文件内有效；静态局部变量只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。
全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。

面试例题3

此题给出求x转化为二进制后包含1的数量的简单解法

{% highlight C++ %}
int count1s(int x){
	int count = 0;
	while(x){
		++count;
		x = x & (x-1);
	}
	return count;
}
{% endhighlight %}

##5.2##

###面试例题2###

注意C中printf()计算参数时是从右向左压栈的。

##5.4##

###面试例题1###

32位机器中，int,long型为4个字节，short为2个字节，double为8个字节，char为1个字节。
float为单精度浮点数，内存中占4个字节，有效位6-7位，double为双精度，占8个字节，有效位15位。
(int&)a表示一个对int的引用，指向a，也就是将a的引用强制转换为整型，a所在的内存本来是double类型，但现在我非要按整型来解释它。
这道题考的点是：计算机中整型和浮点型的存储方式是不同的。
float
1		8		23
符号位 指数    尾数
将一个实数转化为C++存储float格式步骤为：
(1)将实数的绝对值化为二进制格式，注意实数的整数部分和小数部分化为二进制的方法不同。
(2)将二进制格式的实数移动小数点化为科学计数法的格式，即小数点在第一位有效数字的右边，1.XXXXX*2^n。
(3)E-127=n,得出的E为指数部分。
(4)实数为正数，符号位为0，负数为1。
(5)XXXXX为尾数部分。

比如题目中的1.0f
1.0转化为二进制是1.0*2^0，所以符号位为0，指数位为127，尾数为0，写成存储方式是
0 011 1111 1000 0000 0000 0000 0000 0000
十六进制显示就是3f80000.

###面试例题2###

这道题把题目中的unsigned int a的值改为0x12345678,把最后要求输出的*b改为*(b+1)能解释的更加清楚一点。
首先，将unsigned int强制转换为unsigned char型，会进行截断，所以i为a的最后一个字节也就时F7.又因为是unsigned型，所以最后输出的时候左端会用0补齐。
其次，char* b = (char*)&a意思是b是一个指向char的指针，它的地址是unsigned int a的地址，但注意这里b是指向char的指针，所以输出*b的话它会取出a的最后一个字节也就是0x78，输出*(b+1)的话它会取出a的倒数第二个字节也就时0x56...etc.
第三点要说的是，因为b是(signed)char*类型的，所以要求输出32位十六进制时会在左端按正负补0或1，0x56/0x78的最高位都是0，所以会在左端补0而输出0x00000056/0x00000078，如果a的值为0x12348678,而输出*(b+1)，由于0x86的最高位为1所以会在左端补1而输出FFFFFF86.

